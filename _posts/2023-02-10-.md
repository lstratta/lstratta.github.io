---
title: Getting Started With Kotlin and Spring Boot
author: Luke
date: 2023-02-10T18:16:37.984Z
categories:
    - Kotlin
    - Spring
    - Tutorial
tags:
    - Spring
    - Gradel
    - Maven
    - Spring-Boot
    - Starter
    - Kotlin
    - Getting Started
---

# Getting Started With Kotlin and Spring Boot

If you want to create a web app with Kotlin, you're going to need a few things. 

The first one of those things you're going to need a web server to be able to serve the stuff you're going to be creating; whether that is millions of users, or just a local project.

Next up, you might need a way to connect to a database so that you can write some Kotlin to query against it. After that you might need a way to create an API so that you can actually connect to the database.

These things, and so many more all come in this neat package called Spring Boot.

## Where do you get all these things? 

Well, the wonderful people over at Spring have put together this handy tool called the <a href="https://start.spring.io" target="_blank">Spring Initializr</a>.

It's a click-click-click-done wizard that then downloads a zip file with all the dependencies you need to get started writing your Kotlin app.

![The Spring Initializr](../assets/images/2023-08-11-getting-started-with-kotlin-and-spring-boot/Screenshot%20from%202023-02-10%2020-23-39.png)

Here you choose your language, the Spring Boot version, add your roject metadata, and choose your JVM version.

## Dependency... heaven? 

You can also add a plethora of dependencies that are appropriate for you project. 

Want that web server we mentioned? You've got Spring Web. 

Want to connect a SQL database? Whack in Spring Data JDBC.

Want to make sure your data migrations are as slick as can be? Sprinkle in a bit of Liquibase.

There is an absolute boat-load of dependencies to choose from, so window shop a bit and see what will fit your requirements the best.

Only choose what you need though, you don't want to end up in _dependency hell_ (imagine reading that in a big boomy voice).

## Like Lego

Like every tutorial out there, we're going to put together a simple API to walk you through the process of actually running your first Spring Boot app. 

But don't you worry. I am going to help you start to work with more advanced topics in the future; all the stuff I wish I had been able to find when I started out.

![Spring Boot Dependencies](../assets/images/2023-08-11-getting-started-with-kotlin-and-spring-boot/Screenshot%20from%202023-02-10%2020-36-02.png)

For our simple API, we have chosen:
* Spring Web to allow us to have a server for our app and allow us to create a RESTful API
* Spring Data JPA to allow us to connect with SQL databases using the Java Persistence API
* H2 Database which is an in-memory database; great for testing.
* We're also going to use Gradle as the build tool for this project - there's not enough Gradle content out there, so this is the beginning of my contributions.

All we need to do now is hit `GENERATE` and we're off to the races. That will download a zip file for you and all you need to do is unzip it in the location of your choice.

## Just as good as opening presents! Well, kind of.

Now that we've got the zip file downloaded and unzipped, we can open up the folder inside your IDE of choice. I am using IntelliJ, but use whatever you're happiest with.

IntelliJ has gone off and started to to automatically download all the dependencies we specified in in the Spring Initializr, as well as the ones that were put in there by Spring Boot.

![IntelliJ doing it's thing](../assets/images/2023-08-11-getting-started-with-kotlin-and-spring-boot/Screenshot%20from%202023-02-10%2020-51-47.png)

## While it's doing that, let's take a look at what files we have in the project.

![The Project Files](../assets/images/2023-08-11-getting-started-with-kotlin-and-spring-boot/Screenshot%20from%202023-02-10%2020-57-09.png)

Taking a look at the contents of the `superapp` folder we have a few key files and directories. 

`gradle/` contains the files to run gradle in the project so you don't have to download it onto your computer. It comes nicely packaged in the Spring Boot starter.

`build.gradle.kts` contains everything related to building the project (no surprise there really.) It contains the of things that make Gradle the incredible tool it is. Currently, it has the core plugins required for Kotlin to work with Spring, the dependencies that were downloaded by IntelliJ and a feature of Gradle call `tasks`. We'll get into what all those are later on.

`gradlew` is the wrapper for Gradle: that's what we'll be use to run `build tasks`. `gradlew` is for Linux and Mac, `gradlew.bat` is for Windows. 

`settings.gradle.kts` is the file that contains information about build projects. You can have multiple subprojects in a Gradle project, and this is where you would define that information.

## Shut up and write some code

Alright, let's write some code, shall we? 

Let's get a simple API up and running. We're going to need a couple of things:

1. We'll need a data model that is represented in the database.
2. We'll need a controller that will handle requests and respond with objects.
3. We'll need a schema in the database so that the database knows to create the tables on app startup.

Typically, we'd have more separation between these layers, but for the purposes of respecting your time, we'll skip a few steps.

## The Data Model

Let's create the data model first.

![The Super Hero Data Model](../assets/images/2023-08-11-getting-started-with-kotlin-and-spring-boot/Screenshot%20from%202023-02-10%2021-49-39.png)

We've used the Kotlin `data class` here because as we're holding data in this object. Normal classes have some methods that need to be overridden - data classes take care of that for us.

#### jakarta.persistence

`jakarta.persistence` is a persistence and object/relational mapping standard which comes with Spring version `3.x` - another one you'll see is `javax.persistence`. Either one of these will be required to enable us to use this data class as an entity in the database, which...

#### @Entity

Is exactly what `@Entity` does for us. It defines to Jakarta that this is a data model for the database to create a table for. The `name = "superhero"` field tells the database what to name the table. In this case, it is just the lowercase version of the name of the class. 

#### @Id

`@Id` adds the primary key constraint to eh the `dbKey` field. `@GeneratedValue` tells the database that this is a value that needs to be generated each time a new object is saved to the database. `strategy = GenerationType.IDENTITY` indicates to Jakarta that it must assign primary keys for the entity. This value is also set to `0` because databases will treat that as a value that needs to have a primary key value assigned to it.

#### The id field

You might be wondering why I also have an `id` field. This is because I like to keep the database primary keys and ids of an entity separate. Typically, the database key will never be shared outside of the data layer - not something we have in this demo but good to point out. Each to their own, this is how I like to do it. Programming is a creative thing after all. This field holds a string value, but this will be a randomly generated `UUID`.

#### @Column

You'll notice a couple of annotations labelled `@Column` all these do are define the name of the column in the database table. Typically, SQL databases have the table names and columns in lowercase with an underscore `_` between words. Just like in `@Entity`, `name = normie_name` is what we are calling that column.

## A repository for all your super heroes

This next file is pretty easy. This is what does all of the database interaction.

![The Super Hero Repository](../assets/images/2023-08-11-getting-started-with-kotlin-and-spring-boot/Screenshot%20from%202023-02-10%2022-01-26.png)

The `SuperHeroRepository` is an interface that implements the `CrudRepository` interface which accepts two values. The type of the object (or table - but not the table name if it is different to the name of the object) you want to interact with, and the type of the primary key value. In this case, the object/table is the `SuperHero` object and the type of its primary key is `Long`.

That's it! **C**reate, **R**ead, **U**pdate, **D**elete actions are already implemented for us. Spring also does some magic for us if we want to create more adventurous database queries, but that will be in a later post.

Onto the controller.

## \*pssshhhh\* "This is control."

Now this is looking good.

![The Super Hero Controller](../assets/images/2023-08-11-getting-started-with-kotlin-and-spring-boot/Screenshot%20from%202023-02-10%2022-24-12.png)

We've done a few things here.

1. Created a REST conroller with a mapping of `/super-hero`.
2. Created an endpoint for a get request on `/super-hero`.
3. created a `SuperHeroResponse` object to make sure our RESTful API is REST compliant.
4. Connected to the `SuperHeroRepository` to make a `findAll` query and returned that as a field within the `SuperHeroResponse` object.

Usually, we'd be making these repository calls inside a service layer, but this is for simplicity.

## Where is everybody? 

Great. We've set up the API with an endpoint of `/super-hero` that we can make `GET` requests against. We've connected to the repository that makes a `findAll()` query on the `SuperHero` entity table.

But we have no data in the database, which means we have no Super Heroes to call upon in our time of need.

Let's populate the database with our Super Heroes.

![Create tables and insert data](../assets/images/2023-08-11-getting-started-with-kotlin-and-spring-boot/Screenshot%20from%202023-02-10%2023-21-52.png)

Here we have a simple SQL script in the `resources/sql` path. I created the `sql/` directory, it won't be there by default.

```sql
CREATE TABLE IF NOT EXISTS super_hero (
    db_key BIGINT,
    id VARCHAR(36) UNIQUE NOT NULL,
    name VARCHAR(40) NOT NULL,
    normie_name VARCHAR(40),
    PRIMARY KEY (db_key)
);

INSERT INTO super_hero(
    db_key,
    id,
    name,
    normie_name
    )
VALUES
    (1, 'b54d0452-3cec-4078-8ba2-e01cc27f0fe9', 'Iron Man', 'Tony Stark'),
    (2, '51df1d16-d3c4-456b-8bb6-b90b6a39d3e9', 'Batman', 'Bruce Wayne'),
    (3, 'e545657c-dc70-4c56-9279-cdb7c1204ffe', 'Starlord', 'Peter Quill');
```

Next, we need to specify some details to our application.

![Add data to application.properties](../assets/images/2023-08-11-getting-started-with-kotlin-and-spring-boot/Screenshot%20from%202023-02-10%2023-23-54.png)

We've got a few things here that allow us to connect to the database and allow us to populate the database.

`spring.datasource.driver-class-name=org.h2.Driver` provides us with the driver to use our database of choice, here being H2.

`spring.datasource.url=jdbc:h2:mem:superdb` provides us our database URL to connect to shortly. `superdb` can be changed to anything you like.

`spring.h2.console.enabled=true` allows us to access the console at the URL we defined above.

`spring.jpa.defer-datasource-initialization=true` initialises our database for us.

`spring.jpa.properties.hibernate.format_sql=true` not required, but formats SQL in the terminal for a nicer viewing experience.

`spring.sql.init.schema-locations=classpath:sql/data.sql` tells Spring where the location of our SQL script is.

`spring.sql.init.mode=always` tells Spring to always initialise our database.

```
spring.datasource.url=jdbc:h2:mem:superdb
spring.h2.console.enabled=true
spring.jpa.defer-datasource-initialization=true
spring.jpa.properties.hibernate.format_sql=true
spring.sql.init.schema-locations=classpath:sql/data.sql
spring.sql.init.mode=always
```

